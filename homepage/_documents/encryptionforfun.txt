Cryptography For Fun

Cryptography is the science of secret writing. That said, cryptography can be found in many applications in the world including games, puzzles, email, Digital Rights Management (DRM), digital signatures, media streams (both analog and digital), and many others. The key to cryptography is the method of both encryption and decryption. Cryptographic systems come in many flavors. Some forms are replacement based, and others are cyclic or encrypt using a key-based system rather than a set of all possibilities.

An example of replacement based encryption might be the following simple key:

[code]
A B C D E F G H I J K L M
Z Y X W V U T S R Q P O N
[/code]

In this example, the key is symmetric, or in other words the same key may be used to encrypt and decrypt messages.

If you take the phrase, "Hackthissite.org teaches hacking and basic technological understanding." using the symmetrical replacement key, then you get the following cypher-text:

Szxpgsrhhrgv.lit gvzxsvh szxprmt zmw yzhrx gvxsmloltrxzo fmwvhgzmwrmt.

One of the biggest problems with this encryption algorithm is the size of the key and the relationships in the key. The key only contains 26 letters, and effectively has 13 bi-directional replacements. On top of that a quick analysis shows obvious patterns like word size, spaces, punctuation, and duplicate letters together. If the text were very large, then a dictionary could be used to figure out one or two word revealing the letter replacement scheme.

Let's take the same topology for the key and transform it into a cyclic key:

[code]
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
---------------------------------------------------
Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
Y X W V U T S R Q P O N M L K J I H G F E D C B A Z
X W V U T S R Q P O N M L K J I H G F E D C B A Z Y
W V U T S R Q P O N M L K J I H G F E D C B A Z Y X
V U T S R Q P O N M L K J I H G F E D C B A Z Y X W
[/code]

Now we have five keys in effect, acting as one key. In this case, you would use each row of the key in a cyclic manner or cycling through each row for each letter. Taking the same plain text message, we could get the following cypher text.

Syvmcsqfengu.vij guauovg qwtpqkq vmv wwdrw euomkmiprwxl bmvtfdgyktnms.

This is somewhat more difficult to automatically decrypt because letters that are duplicated together are not as likely to create common duplicate letters as found in the English language. We still have the problem of punctuation and obvious word separation, and if you notice there is one instance where the actual unencrypted letter is the same as the encrypted letter, which may be considered a flaw in the key, namely on line four, L == L. But now for example, vmv, is a more difficult word to decrypt since there are no three-letter words in the English language that begin and end with the same letters aside from names, like Mom, Dad, and Bob. But since the first letter of vmv is not capitalized, we can guess that it is not a name (unless the writer did not speak English very well.)

Let's now briefly look at an encryption algorithm that I created when I was younger, which I call Five-bit Encryption. Five-bit Encryption defines the alphabet as all capital letters, removing any possibility that letters may be guessed by seeing capitals, and defines the alphabet within a five-bit space, or 31 characters. This makes it possible to encrypt spaces and common punctuation like periods and commas.

The key appears something like the following:

[code]
A B C D E F G H I J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  .  ,  '  <sp> [31]
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30    31
[/code]

This key also uses a binary number system that only uses letters. Since we are using five bits, we need five bit-fields, which are formally designated as ABCDE where E == 2^0 == 1.

As an example of encryption using this algorithm let me simply encrypt my name, Nathan:

BCDEACBEBCD

Now you see a jumble of the five letters I mentioned, each representing a bit-field. The problem with this algorithm that you'll see now is that it is difficult to decrypt the message being relayed. The method of decryption is to follow until the letters until you reach a letter representing a higher bit-field than the previos one. So breaking up the message we see the following characters:

BCDE AC BE BCD

Only four characters and not six!!! This problem occurs because not every instance of a letter will include a higher bit to start than the last bit of the last letter. Ideally we would somehow come to six letters, but let's decrypt what we have now to see what we get.

[code]
15 20 9 14
O  T  I  N
[/code]

[i]Otin[/i] is not even close to the original message. Except that it contains two of the original letters. This is what's called a lossy encryption algorithm. Lossy encryption is often used where messages don't need to be perfectly what they were. One place where lossy algorithms are used is in JPEG compression. JPEG compression, however removes parts of the image that aren't important to the viewer. In this case we're missing some very important pieces. In order to get the original message back from this encryption we must calculate all of the permutations of this message and match against them something that makes sense. Eventually we would come across

[code]
14 1 20 8 1 14
N  A T  H A N
[/code]

But you can now see clearly where the problem lies.

When creating encryption two possibilities are available, similar to when we're optimizing a program, 1) speed, or 2) difficulty. We can't have both because it takes a long time to generate a difficult to crack key, and a fast algorithm requires a relatively small key. The answer to the speed problem is block-cypher algorithms.

Block-cypher algorithms rely on symmetrical keys, meaning that the same key and algorithm is used to both encrypt and decrypt a message. A very simple, no brainer example of this would be to perform XOR between a key and the cypher text. Binarily speaking XOR will always produce a 1 where a 1 is one of two operands and a 0 (zero) where both operands are either 1 or 0. For example:

0 XOR 0 == 0
0 XOR 1 == 1
1 XOR 0 == 1
1 XOR 1 == 0

Now using this knowledge and understanding that bytes or the characters that you see on the screen are made up of bits or 1's and 0's, we can perform some basic encryption. First let's create a key.

Example key:
Hi my name is Nathan Lane

(Remember that the longer the key is the more is will do for a longer message)

Example plain-text:
This is an example message that is absolutely arbitrary and serves no purpose but to be used in this example

Bit Table
[code]
A 00000		N 01101		<sp> 11010
B 00001		O 01110		.    11011
C 00010		P 01111		,    11100
D 00011		Q 10000		'    11101
E 00100		R 10001		?    11110
F 00101		S 10010		0    11111
G 00110		T 10011
H 00111		U 10100
I 01000		V 10101
J 01001		W 10110
K 01010		X 10111
L 01011		Y 11000
M 01100		Z 11001
[/code]

Both the message and key here are a good size. Now using the table above we will perform XOR on each character based on this matching.

TEXT:   this is an example message that is absolutely arbitrary and serves no purpose but to be used in this example
KEY:    hi my name is nathan lanehi my name is nathan lanehi my name is nathan lanehi my name is nathan lanehi my na

XORed we get this:

CYPHER: ups?cs  mjamf bpyd b?zsncdsjlyjxi?? jauguadlvalrmmuz 'aannp?imdpjsjkoxv rckvmanmjxtc?.mio eq'iaayhfw'mnmuvge

Now you can see that this is a pretty difficult message to decode. This is because the encryption was cyclic. However all we need is the correct key. Since we know that key, the same operation produces the plain text again.

CYPHER: ups?cs  mjamf bpyd b?zsncdsjlyjxi?? jauguadlvalrmmuz 'aannp?imdpjsjkoxv rckvmanmjxtc?.mio eq'iaayhfw'mnmuvge
KEY:    hi my name is nathan lanehi my name is nathan lanehi my name is nathan lanehi my name is nathan lanehi my na

XORed we get the plain text again:

TEXT:   this is an example message that is absolutely arbitrary and serves no purpose but to be used in this example

That is how a block cypher works. The same key and algorithm are used both to encrypt and decrypt messages. Block cyphers are often used in encrypting media, like DVDs, streams, and other signal broadcasts. DRM is one of these, and therein is where the problem lies. Block cyphers aren't very good encrpytion, they're just okay and they're fast. But that is why it was so simple to create the deCSS library which decoded DVDs for Linux. [url=http://en.wikipedia.org/wiki/Jon_Lech_Johansen]Jon Johansen[/url] of Norway single handedly decoded Sony's DVD-based CSS (Content Scrambling System) with little more than analysis and a lot of patience. He stumbled across the two necessary pieces needed to decrypt DVDs to be played without special software players or hardware DVD players. He found the algorithm and found out that the key was being stored in plain text on the media itself.

Another type of cryptography is [url=http://en.wikipedia.org/wiki/Histogram]histographical[/url] cryptography. This type of cryptography takes into account all of the possibilities available in a single message and encrypts using them. The key is typically supplied with the message since it varies from message to message and is completely message dependent. Histographical encryption is often used for data compression. Algorithms like Gzip, Bzip, Zip, 7-zip, and Rar all use histographical information to compress the files that are stored in their archives. One of the most common open standards for data compression is [url=http://en.wikipedia.org/wiki/Lzma]LZMA (Lempel-Ziv-Markov chain algorithm[/url], but I won't go into that now. [url=http://www.hackthissite.org/forums/viewtopic.php?f=28&t=954#p7093]In a recent post[/url] I briefly discussed coming to a solution of an encrypted message by analyzing the data and discovering the plain text by histographical data, for example that the letter 'e' is the most common in the English language and that the space is even more common.

Well that's all for now. I hope that this was somewhat useful to some. Take it as a primer in cryptography. Thanks.